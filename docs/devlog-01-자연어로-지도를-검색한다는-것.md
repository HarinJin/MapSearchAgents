# 개발일지: 자연어로 지도를 검색한다는 것

*2026-01-20 ~ 2026-02-18*

---

## 1. "노가리 까기 좋은 곳"을 검색창에 칠 수 있다면

프로젝트의 출발점은 단순한 불만이었다. 카카오맵에 "노가리 까기 좋은 곳"이라고 치면 검색이 안 된다. "속이 편한 음식점"도 안 된다. 지도 앱은 "호프", "포차", "해장국"처럼 정확한 키워드를 요구하는데, 사람은 그렇게 생각하지 않는다.

그래서 **자연어를 이해하는 지도 검색 시스템**을 만들기로 했다. 은어, 맥락, 분위기 같은 비정형 표현을 API가 이해할 수 있는 키워드로 변환하고, 그 결과를 지도 위에 보여주는 구조다.

초기 설계에서 4단계 에이전트 파이프라인을 확정했다.

```
사용자 쿼리 → Translator → MapSearch → APIPicker → 결과
```

**Translator**가 은어를 해석하고, **MapSearch**가 검색 전략을 수립하고, **APIPicker**가 실제 API를 호출한다. 중앙의 **Operator**(CLAUDE.md)가 이 흐름을 오케스트레이션한다.

핵심 설계 결정 하나. 에이전트가 은어를 해석할 때 **LLM의 추론에만 의존하지 않고, 레퍼런스 파일을 참조**하도록 했다. `.claude/skills/map-search/references/` 아래에 은어 사전을 두고, Translator가 이걸 먼저 읽은 뒤 매칭을 시도한다. 매칭되면 신뢰도 0.9+, 레퍼런스에 없으면 LLM 추론으로 넘어가되 신뢰도를 낮게 표시한다. 할루시네이션 방지와 일관성을 위한 장치였다.

```
references/
├── slang-food.md      # "노가리" → 호프/포차, "속이 편한" → 해장국/죽
├── slang-space.md     # "작업하기 좋은" → 콘센트/와이파이
├── slang-activity.md  # "데이트" → 이탈리안/브런치
└── slang-context.md   # "20대 여자친구" → 인스타 감성
```

---

## 2. 첫 테스트, 그리고 연쇄적인 문제들

첫 번째 실전 쿼리는 "광교중앙역 근처에서 속이 편한 음식을 파는 가게"였다. 파이프라인이 돌았다. Translator가 `slang-food.md`를 참조해서 "속이 편한"을 해장국/죽/설렁탕으로 변환했고, APIPicker가 카카오 API를 호출해서 결과를 뽑았다.

근데 결과에 **칼국수집**이 포함되어 있었다. "속이 편한 음식"이라고 했는데 밀가루 음식이 나온 거다. 사용자 피드백을 받아 `slang-food.md`의 "속이 편한" 항목에 칼국수를 제외 키워드로 추가했다. 반대로 한정식(나물류)은 포함 키워드로 넣었다. 레퍼런스 파일을 분리해둔 덕분에 에이전트 로직은 건드리지 않고 사전만 수정하면 됐다.

두 번째 테스트는 더 복잡했다. "잠실 근처에서 어린아이 둔 부모가 반나절, 여가+식사+커피." 여기서 두 가지 버그가 터졌다.

**버그 1 — URL 누락.** 검색 결과에 장소명과 주소만 있고 링크가 없었다. "롯데월드 아쿠아리움"이라고 알려주는데 정작 찾아가려면 다시 카카오맵에서 검색해야 하는 상황. `place_url` 필수 포함 규칙을 CLAUDE.md에 추가했다.

**버그 2 — URL 오매칭.** 이건 더 심각했다. "롯데월드 아쿠아리움"을 클릭했더니 "포천병원 장례식장"이 열렸다. 원인을 추적해보니, Claude의 대화 컨텍스트가 길어지면서 이전 내용이 요약(compaction)되는데, 이 과정에서 오퍼레이터가 요약본에 있던 URL을 "기억"에서 꺼내 쓴 거였다. 실제 API 결과가 아니라 환각으로 만든 URL이었다.

해결책은 강경했다. "**현재 세션에서 실행한 API 결과만 사용할 것. 이전 대화 요약이나 기억에서 가져온 place_url은 절대 신뢰하지 말 것.**" 이 규칙을 CLAUDE.md에 박아넣었다.

---

## 3. 텍스트를 넘어 지도로 — 그리고 Google API의 등장

터미널에 텍스트 테이블로 결과가 나오는 건 개발자한테는 괜찮지만, 실제로 어디에 있는지 감이 안 온다. "지도로 보고 싶다"는 요구가 자연스럽게 나왔다.

기술 선택에서 작은 고민이 있었다. 카카오 Maps JS API는 API 키에 도메인을 등록해야 해서 로컬 HTML 파일에서 바로 못 쓴다. **Leaflet.js + OpenStreetMap** 조합은 API 키 없이 로컬에서 즉시 작동한다. 이 프로젝트가 CLI 도구이고 결과를 로컬 HTML로 열어보는 방식이라 Leaflet을 택했다.

첫 번째 지도 페이지에 카테고리별 색상 마커, 마커 클릭 시 팝업, 사이드바 장소 클릭 시 지도 자동 이동까지 넣었다. 여기서 또 하나의 문제를 만났다.

**"지금 열려 있는 곳만 보여줘."**

카카오 API는 영업시간을 제공하지 않는다. 카카오맵 앱에서는 보이지만 API로는 안 내려준다. 트래픽을 앱으로 유도하려는 정책인지, 데이터 책임 회피인지 모르겠지만, 어쨌든 시간 조건 필터링이 불가능했다.

**Google Places API를 보조 수단으로 도입**했다. 기본은 카카오, 시간 조건이 있을 때만 Google을 쓰는 전략이다. 카카오로 장소를 찾은 뒤, Google Find Place로 같은 장소의 `place_id`를 확보하고, Place Details로 영업시간을 조회하는 3단 구조다.

이때 **PlaceEnricher** 에이전트와 **시간 조건 감지 사전**(`slang-time.md`)이 추가됐다. Translator가 "지금", "영업중인", "24시" 같은 표현을 감지하면 `requires_enrichment: true`를 반환하고, 오퍼레이터가 PlaceEnricher를 호출하는 흐름이다.

해외 검색도 자연스럽게 풀렸다. "도쿄 시부야 라멘"처럼 해외 지명이 감지되면 Translator가 `provider: "google"`을 반환하고, APIPicker가 Google Places API를 사용한다. 국내는 카카오, 해외는 구글 — provider 분기가 완성됐다.

---

## 4. Travel Planner — 3패널 지도 UI

단일 지도 페이지에서 한 단계 올라갔다. **Travel Planner Map** — 지도를 중심에 놓고, 좌측에 장소 목록, 우측에 여행 계획 패널을 배치하는 3패널 레이아웃이다.

끄라비 무에타이 체육관 검색으로 실전 테스트를 했다. "디바나 플라자 크라비 숙소 기준, 무에타이 체육관." Google Places API가 Knockout Muay Thai Gym 등 6곳을 찾았고, 영업시간까지 포함된 결과가 3패널 레이아웃으로 렌더링됐다. 마커 클러스터링, 카테고리 필터, 거리/평점 정렬까지 들어갔다.

이 시점에서 **JSON → HTML 자동 생성 방식**을 확정했다. 매번 Claude가 HTML을 직접 작성하는 대신, 에이전트가 일정한 JSON을 출력하면 스크립트가 템플릿에 주입하는 구조. 이유는 단순하다 — 일관성과 속도. Claude가 HTML을 매번 쓰면 토큰이 낭비되고 결과물도 매번 다르다. JSON 스키마 하나 합의해두고 자동화하는 게 낫다.

스키마를 바로 고정할까 고민했지만, 기능이 아직 다 완성되지 않아서 **핵심 필드만 유지하되 확장 가능하게** 두기로 했다.

GitHub에 공개 레포로 올리고 Initial commit을 찍었다. API 키는 `.env` 파일에만 있고 git에 포함되지 않았음을 확인했다.

---

## 그동안 만들어진 것들

### 에이전트 (4개)

| 에이전트 | 역할 |
|---------|------|
| Translator | 은어/맥락 해석, provider 분기 |
| MapSearch | 검색 전략 수립 (반경/경로) |
| APIPicker | API 실행 (카카오/구글) |
| PlaceEnricher | 시간 조건 보강 |

### 스크립트 (3개)

| 파일 | 역할 |
|------|------|
| `scripts/kakao-search.js` | 카카오 로컬 API CLI 래퍼 |
| `scripts/google-places.js` | Google Places API CLI 래퍼 |
| `scripts/types/place.js` | 장소 데이터 정규화 (카카오/구글 통합) |

### 레퍼런스 (9개)

은어 사전 5개 (`slang-food/space/activity/context/time.md`), 전략 2개 (`strategy-radius/route.md`), API 명세 2개 (`api-commands.md`, `api-google-places.md`)

### 설계 문서

| 파일 | 내용 |
|------|------|
| `docs/completed-features.md` | 에이전트 응답 형식 표준화 기록 |
| `docs/frontend-ux-plan.md` | 프론트엔드 UX 설계 초안 |

### 주요 설계 결정

| 결정 | 이유 |
|------|------|
| 카카오 기본, Google은 시간/해외만 | 국내 데이터 품질 + API 비용 절약 |
| 레퍼런스 파일 기반 은어 해석 | 할루시네이션 방지, 사전 수정만으로 행동 변경 |
| Leaflet.js + OSM | API 키 없이 로컬 HTML 즉시 작동 |
| JSON → 템플릿 자동 생성 | 일관성, 토큰 절약, UI 수정 시 템플릿 하나만 변경 |
| place_url 필수 + API 결과만 신뢰 | compaction 후 URL 환각 버그 방지 |
| 칼국수 = "속 편한 음식"에서 제외 | 밀가루 음식은 소화 부담, 사용자 피드백 반영 |
